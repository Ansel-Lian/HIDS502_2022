---
title: "Lecture 11 In Class Framework"
format: 
  html:
    self-contained: true
---
```{r setup, include=FALSE}
#| warning: false
library(tidyverse)     # loads the tidyverse tools
library(RPostgres)     # loads the database driver for PostgreSQL
library(connections)   # helps RPostgres work with RStudio
library(keyring)       # access to a local encrypted keychain for passwords

con <- connection_open(RPostgres::Postgres(),
          dbname = "syntheticmguh",
          host = "35.199.26.47",
          user = "hids502_student",
          password = key_get(service = "syntheticmguh", 
                             username = "hids502_student"),
          # Tell the driver to return very large integers as floating point (vs truncating them)
          bigint = "numeric")

knitr::opts_chunk$set(connection = "con")
```

# Class Examples

## Big Data

```{sql connection=con}
WITH observations_per_encounter AS (
    SELECT encounter, count(*) as heart_rate_observations
    from observations
    where code = '8867-4'
    group by encounter)
SELECT avg(heart_rate_observations)
FROM observations_per_encounter;
```


## String Matching

```{sql connection=con}
SELECT count(*)
FROM notes 
WHERE LOWER(note_text) LIKE '%hea_ache%' OR LOWER(note_text) LIKE '%migraine%'
```

```{sql connection=con}
SELECT count(*)
FROM notes
WHERE note_text ~* 'headache|migraine'
```

```{sql connection=con}
SELECT 
  'Cobb' as name,
  soundex('Cobb') as soundex_name,
  metaphone('Cobb', 10) as metaphone_name
```

```{sql connection=con}
SELECT 
  levenshtein('Cobb', 'Kobb') Cobb_Kobb,
  levenshtein('Cobb', 'Kob') Cobb_Kob,
  levenshtein('Cobb', 'Frank') Cobb_Frank
```



```{sql connection=con}
select apr1.first, apr1.last, count(DISTINCT apr1.enterpriseid)
FROM patient_matching_challenge.all_patient_records AS apr1
-- This is a self-join, we are going to join the same table to
-- itself; to do so we need to give each copy a unique name
LEFT JOIN patient_matching_challenge.all_patient_records AS apr2
 ON apr1.last = apr2.last and apr1.first = apr2.first
  -- Lets only take records on the right hand side where they aren't
  -- the record on the left!
  AND apr1.enterpriseid <> apr2.enterpriseid
-- Here we limit to just records (on the left) that have both
-- a first and last name
WHERE apr1.last IS NOT NULL and apr1.first IS NOT NULL
-- Now group by enterpriseid; the names are redundant to helpful to us
GROUP BY apr1.enterpriseid, apr1.first, apr1.last
-- But only records where there are more than 1 copy
HAVING count(DISTINCT apr1.enterpriseid) > 1
ORDER BY count(DISTINCT apr1.enterpriseid) desc
LIMIT 5;
```

